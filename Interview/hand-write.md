---
url: https://interview.poetries.top/docs/base/handwritten.html#_20-%E4%BF%AE%E6%94%B9%E5%B5%8C%E5%A5%97%E5%B1%82%E7%BA%A7%E5%BE%88%E6%B7%B1%E5%AF%B9%E8%B1%A1%E7%9A%84-key
title: 面试高频手写题 | 前端进阶之旅
date: 2023-09-25 12:33:31
tag: 
summary: 前端面试题进阶总结，按模块分类精心整理，打造最全面的前端面试题库，为你的前端面试之旅保驾护航！
outline: deep
---
**建议优先掌握：**

*   `instanceof` - 考察对原型链的理解
*   `new` - 对创建对象实例过程的理解
*   `call/apply/bind` - 对`this`指向的理解
*   手写`promise` - 对异步的理解
*   手写原生`ajax` - 对`ajax`原理和`http`请求方式的理解，重点是`get`和`post`请求的实现

## 1 实现防抖函数（debounce）

防抖函数原理：**把触发非常频繁的事件合并成一次去执行** 在指定时间内只执行一次回调函数，如果在指定的时间内又触发了该事件，则回调函数的执行时间会基于此刻重新开始计算

![](<./hand-write.assets/1695616411695.png>)

![](<./hand-write.assets/1695616412738.png>)

防抖动和节流本质是不一样的。**防抖动是将多次执行变为`最后一次执行`，节流是将多次执行变成`每隔一段时间执行`**

eg. 像百度搜索，就应该用防抖，当我连续不断输入时，不会发送请求；当我一段时间内不输入了，才会发送一次请求；如果小于这段时间继续输入的话，时间会重新计算，也不会发送请求。

**手写简化版:**

**适用场景：**

*   文本输入的验证，连续输入文字后发送 AJAX 请求进行验证，验证一次就好
*   按钮提交场景：防止多次提交按钮，只执行最后提交的一次
*   服务端验证场景：表单验证需要服务端配合，只执行一段连续的输入事件的最后一次，还有搜索联想词功能类似

## 2 实现节流函数（throttle）

节流函数原理: 指频繁触发事件时，只会在指定的时间段内执行事件回调，即触发事件间隔大于等于指定的时间才会执行回调函数。总结起来就是：**事件，按照一段时间的间隔来进行触发**。

![](<./hand-write.assets/1695616412776.png>)

![](<./hand-write.assets/1695616412814.png>)

像 dom 的拖拽，如果用消抖的话，就会出现卡顿的感觉，因为只在停止的时候执行了一次，这个时候就应该用节流，在一定时间内多次执行，会流畅很多

**手写简版**

使用时间戳的节流函数会在第一次触发事件时立即执行，以后每过 `wait` 秒之后才执行一次，并且最后一次触发事件不会被执行

**时间戳方式：**

**定时器方式：**

使用定时器的节流函数在第一次触发时不会执行，而是在 delay 秒之后才执行，当最后一次停止触发后，还会再执行一次函数

**适用场景：**

*   拖拽场景：固定时间内只执行一次，防止超高频次触发位置变动。`DOM` 元素的拖拽功能实现（`mousemove`）
*   缩放场景：监控浏览器`resize`
*   滚动场景：监听滚动`scroll`事件判断是否到页面底部自动加载更多
*   动画场景：避免短时间内多次触发动画引起性能问题

**总结**

*   **函数防抖**：`限制执行次数，多次密集的触发只执行一次`
    *   将几次操作合并为一次操作进行。原理是维护一个计时器，规定在`delay`时间后触发函数，但是在`delay`时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。
*   **函数节流**：`限制执行的频率，按照一定的时间间隔有节奏的执行`
    *   使得一定时间内只触发一次函数。原理是通过判断是否到达一定时间来触发函数。

## 3 实现 instanceOf

**思路：**

*   步骤 1：先取得当前类的原型，当前实例对象的原型链
*   ​步骤 2：一直循环（执行原型链的查找机制）
    *   取得当前实例对象原型链的原型链（`proto = proto.__proto__`，沿着原型链一直向上查找）
    *   如果 当前实例的原型链`__proto__`上找到了当前类的原型`prototype`，则返回 `true`
    *   如果 一直找到`Object.prototype.__proto__ == null`，`Object`的基类 (`null`) 上面都没找到，则返回 `false`

![](<./hand-write.assets/1695616414188.png>)

## 4 实现 new 的过程

**new 操作符做了这些事：**

*   创建一个全新的对象`obj`，继承构造函数的原型：这个对象的`__proto__`要指向构造函数的原型`prototype`
*   执行构造函数，使用 `call/apply` 改变 `this` 的指向（将`obj`作为`this`）
*   返回值为`object`类型则作为`new`方法的返回值返回，否则返回上述全新对象`obj`

## 5 实现 call 方法

**call 做了什么:**

*   将函数设为对象的属性
*   执行和删除这个函数
*   指定`this`到函数并传入给定参数执行函数
*   如果不传入参数，默认指向 `window`

**分析：如何在函数执行时绑定 this**

*   如`var obj = {x:100,fn() { this.x }}`
*   执行`obj.fn()` , 此时`fn`内部的`this`就指向了`obj`
*   可借此来实现函数绑定`this`

原生`call`、`apply`传入的`this`如果是值类型，会被`new Object`（如`fn.call('abc')`）

## 6 实现 apply 方法

思路: 利用`this`的上下文特性。`apply`其实就是改一下参数的问题

## 7 实现 bind 方法

`bind` 的实现对比其他两个函数略微地复杂了一点，涉及到参数合并 (类似函数柯里化)，因为 `bind` 需要返回一个函数，需要判断一些边界问题，以下是 `bind` 的实现

*   `bind` 返回了一个函数，对于函数来说有两种方式调用，一种是直接调用，一种是通过 `new` 的方式，我们先来说直接调用的方式
*   对于直接调用来说，这里选择了 `apply` 的方式实现，但是对于参数需要注意以下情况：因为 `bind` 可以实现类似这样的代码 `f.bind(obj, 1)(2)`，所以我们需要将两边的参数拼接起来
*   最后来说通过 `new` 的方式，对于 `new` 的情况来说，不会被任何方式改变 `this`，所以对于这种情况我们需要忽略传入的 `this`
*   箭头函数的底层是`bind`，无法改变`this`，只能改变参数

**简洁版本**

*   对于普通函数，绑定`this`指向
*   对于构造函数，要保证原函数的原型对象上的属性不能丢失

**注意**： `bind`之后不能再次修改`this`的指向（箭头函数的底层实现原理依赖`bind`绑定 this 后不能再次修改`this`的特性），`bind`多次后执行，函数`this`还是指向第一次`bind`的对象

## 8 实现深拷贝

### 1 简洁版本

**简单版：**

**局限性：**

*   他无法实现对函数 、RegExp 等特殊对象的克隆
*   会抛弃对象的`constructo`r, 所有的构造函数会指向`Object`
*   对象有循环引用, 会报错

**面试简版**

调用深拷贝方法，若属性为值类型，则直接返回；若属性为引用类型，则递归遍历。这就是我们在解这一类题时的核心的方法。

**进阶版**

*   解决拷贝循环引用问题
*   解决拷贝对应原型问题

### 2 实现完整的深拷贝

**1. 简易版及问题**

估计这个 api 能覆盖大多数的应用场景，没错，谈到深拷贝，我第一个想到的也是它。但是实际上，对于某些严格的场景来说，这个方法是有巨大的坑的。问题如下：

1.  无法解决`循环引用`的问题。举个例子：

拷贝`a`会出现系统栈溢出，因为出现了无限递归的情况。

2.  无法拷贝一些特殊的对象，诸如 `RegExp, Date, Set, Map`等
3.  无法拷贝`函数`(划重点)。

因此这个 api 先 pass 掉，我们重新写一个深拷贝，简易版如下:

现在，我们以刚刚发现的三个问题为导向，一步步来完善、优化我们的深拷贝代码。

**2. 解决循环引用**

现在问题如下:

这就是循环引用。我们怎么来解决这个问题呢？

创建一个 Map。记录下已经拷贝过的对象，如果说已经拷贝过，那直接返回它行了。

现在来试一试：

好像是没有问题了, 拷贝也完成了。但还是有一个潜在的坑, 就是 map 上的 key 和 map 构成了强引用关系，这是相当危险的。我给你解释一下与之相对的弱引用的概念你就明白了

在计算机程序设计中，弱引用与强引用相对，

被弱引用的对象可以在任何时候被回收，而对于强引用来说，只要这个强引用还在，那么对象无法被回收。拿上面的例子说，map 和 a 一直是强引用的关系， 在程序结束之前，a 所占的内存空间一直不会被释放。

**怎么解决这个问题？**

很简单，让 map 的 key 和 map 构成弱引用即可。ES6 给我们提供了这样的数据结构，它的名字叫 WeakMap，它是一种特殊的 Map, 其中的键是弱引用的。其键必须是对象，而值可以是任意的

稍微改造一下即可:

**3. 拷贝特殊对象**

**可继续遍历**

对于特殊的对象，我们使用以下方式来鉴别:

梳理一下对于可遍历对象会有什么结果：

以这些不同的字符串为依据，我们就可以成功地鉴别这些对象。

**不可遍历的对象**

对于不可遍历的对象，不同的对象有不同的处理。

**4. 拷贝函数**

*   虽然函数也是对象，但是它过于特殊，我们单独把它拿出来拆解。
*   提到函数，在 JS 种有两种函数，一种是普通函数，另一种是箭头函数。每个普通函数都是
*   Function 的实例，而箭头函数不是任何类的实例，每次调用都是不一样的引用。那我们只需要
*   处理普通函数的情况，箭头函数直接返回它本身就好了。

那么如何来区分两者呢？

答案是: 利用原型。箭头函数是不存在原型的。

**5. 完整代码展示**

## 9 实现类的继承

### 1 实现类的继承 - 简版

类的继承在几年前是重点内容，有 n 种继承方式各有优劣，es6 普及后越来越不重要，那么多种写法有点『回字有四样写法』的意思，如果还想深入理解的去看红宝书即可，我们目前只实现一种最理想的继承方式。

### 2 ES5 实现继承 - 详细

**第一种方式是借助 call 实现继承**

这样写的时候子类虽然能够拿到父类的属性值，但是问题是父类中一旦存在方法那么子类无法继承。那么引出下面的方法

**第二种方式借助原型链实现继承：**

看似没有问题，父类的方法和属性都能够访问，但实际上有一个潜在的不足。举个例子：

明明我只改变了 s1 的 play 属性，为什么 s2 也跟着变了呢？很简单，因为两个实例使用的是同一个原型对象

**第三种方式：将前两种组合：**

之前的问题都得以解决。但是这里又徒增了一个新问题，那就是 Parent3 的构造函数会多执行了一次（`Child3.prototype = new Parent3()`;）。这是我们不愿看到的。那么如何解决这个问题？

**第四种方式: 组合继承的优化 1**

这里让将父类原型对象直接给到子类，父类构造函数只执行一次，而且父类属性和方法均能访问，但是我们来测试一下

子类实例的构造函数是 Parent4，显然这是不对的，应该是 Child4。

**第五种方式 (最推荐使用)：优化 2**

这是最推荐的一种方式，接近完美的继承。

## 10 实现 Promise 相关方法

### 1 实现 Promise 的 resolve

实现 resolve 静态方法有三个要点:

*   传参为一个 `Promise`, 则直接返回它。
*   传参为一个 `thenable` 对象，返回的 `Promise` 会跟随这个对象，采用它的最终状态作为自己的状态。
*   其他情况，直接返回以该值为成功状态的`promise`对象。

### 2 实现 Promise.reject

Promise.reject 中传入的参数会作为一个 reason 原封不动地往下传, 实现如下:

### 3 实现 Promise.prototype.finally

前面的`promise`不管成功还是失败，都会走到`finally`中，并且`finally`之后，还可以继续`then`（说明它还是一个 then 方法是关键），并且会将初始的`promise`值原封不动的传递给后面的`then`.

**Promise.prototype.finally 最大的作用**

*   `finally`里的函数，无论如何都会执行，并会把前面的值原封不动传递给下一个`then`方法中
*   如果`finally`函数中有`promise`等异步任务，会等它们全部执行完毕，再结合之前的成功与否状态，返回值

**Promise.prototype.finally 六大情况用法**

**源码实现**

### 4 实现 Promise.all

对于 all 方法而言，需要完成下面的核心功能:

*   传入参数为一个空的可迭代对象，则直接进行`resolve`。
*   如果参数中有一个`promise`失败，那么`Promise.all`返回的`promise`对象失败。
*   在任何情况下，`Promise.all` 返回的 `promise` 的完成状态的结果都是一个数组

### 5 实现 promise.allsettle

MDN: `Promise.allSettled()`方法返回一个在所有给定的`promise`都`已经`fulfilled`或`rejected`后的`promise`，并带有一个对象数组，每个对象表示对应的`promise` 结果

当您有多个彼此不依赖的异步任务成功完成时，或者您总是想知道每个`promise`的结果时，通常使用它。

【译】`Promise.allSettled` 跟 `Promise.all` 类似, 其参数接受一个`Promise`的数组, 返回一个新的`Promise`, 唯一的不同在于, 其不会进行短路, 也就是说当 Promise 全部处理完成后我们可以拿到每个`Promise`的状态, 而不管其是否处理成功。

**用法 | 测试用例**

**实现**

### 6 实现 Promise.race

race 的实现相比之下就简单一些，只要有一个 promise 执行完，直接 resolve 并停止执行

### 7 实现一个简版 Promise

**使用 class 实现**

### 8 Promise 实现 - 详细

*   可以把 `Promise` 看成一个状态机。初始是 `pending` 状态，可以通过函数 `resolve`和 `reject` ，将状态转变为 `resolved`或者 `rejected` 状态，状态一旦改变就不能再次变化。
*   `then` 函数会返回一个 `Promise` 实例，并且该返回值是一个新的实例而不是之前的实例。因为 `Promise` 规范规定除了 `pending` 状态，其他状态是不可以改变的，如果返回的是一个相同实例的话，多个 `then` 调用就失去意义了。
*   对于 `then`来说，本质上可以把它看成是 `flatMap`

### 9 实现 Promisify

### 10 完整实现 Promises/A + 规范

## 11 实现发布订阅模式

**简介：**

发布订阅者模式，一种对象间一对多的依赖关系，但一个对象的状态发生改变时，所依赖它的对象都将得到状态改变的通知。

**主要的作用 (优点)：**

1.  广泛应用于异步编程中 (替代了传递回调函数)
2.  对象之间松散耦合的编写代码

**缺点：**

*   创建订阅者本身要消耗一定的时间和内存
*   多个发布者和订阅者嵌套一起的时候，程序难以跟踪维护

**实现的思路：**

*   创建一个对象 (缓存列表)
*   `on`方法用来把回调函数`fn`都加到缓存列表中
*   `emit` 根据`key`值去执行对应缓存列表中的函数
*   `off`方法可以根据`key`值取消订阅

**测试用例**

**发布订阅者模式和观察者模式的区别？**

*   发布 / 订阅模式是观察者模式的一种变形，两者区别在于，**发布 / 订阅模式在观察者模式的基础上，在目标和观察者之间增加一个调度中心。**
*   **观察者模式**是由具体目标调度，比如当事件触发，`Subject` 就会去调用观察者的方法，所以观察者模式的订阅者与发布者之间是存在依赖的。
*   **发布 / 订阅模式**由统一调度中心调用，因此发布者和订阅者不需要知道对方的存在。

## 12 实现观察者模式

观察者模式（基于发布订阅模式） 有观察者，也有被观察者

**观察者需要放到被观察者中，被观察者的状态变化需要通知观察者** 我变化了 内部也是基于发布订阅模式，收集观察者，状态变化后要主动通知观察者

## 13 实现单例模式

核心要点: 用闭包和`Proxy`属性拦截

## 14 实现 Ajax

**步骤**

*   创建 `XMLHttpRequest` 实例
*   发出 HTTP 请求
*   服务器返回 XML 格式的字符串
*   JS 解析 XML，并更新局部页面
*   不过随着历史进程的推进，XML 已经被淘汰，取而代之的是 JSON。

了解了属性和方法之后，根据 AJAX 的步骤，手写最简单的 GET 请求。

### 1 原生实现

### 2 Promise 实现

基于`Promise`封装`Ajax`

*   返回一个新的`Promise`实例
*   创建`HMLHttpRequest`异步对象
*   调用`open`方法，打开`url`，与服务器建立链接（发送前的一些处理）
*   监听`Ajax`状态信息
*   如果`xhr.readyState == 4`（表示服务器响应完成，可以获取使用服务器的响应了）
    *   `xhr.status == 200`，返回`resolve`状态
    *   `xhr.status == 404`，返回`reject`状态
*   `xhr.readyState !== 4`，把请求主体的信息基于`send`发送给服务器

## 15 实现 JSONP 方法

利用`<script>`标签不受跨域限制的特点，缺点是只能支持 `get` 请求

*   创建`script`标签
*   设置`script`标签的`src`属性，以问号传递参数，设置好回调函数`callback`名称
*   插入到`html`文本中
*   调用回调函数，`res`参数就是获取的数据

*   设置 `CORS: Access-Control-Allow-Origin：*`
*   `postMessage`

## 16 实现 async/await

**分析**

**整体看一下结构**

**分析**

## 17 基于 Generator 函数实现 async/await 原理

核心：传递给我一个`Generator`函数，把函数中的内容基于`Iterator`迭代器的特点一步步的执行

## 18 实现 ES6 的 const

由于 ES5 环境没有`block`的概念，所以是无法百分百实现`const`，只能是挂载到某个对象下，要么是全局的`windo`w，要么就是自定义一个`object`来当容器

`Vue`目前双向绑定的核心实现思路就是利用`Object.defineProperty`对`get`跟`set`进行劫持，监听用户对属性进行调用以及赋值时的具体情况，从而实现的双向绑定

## 19 实现一个迭代器生成函数

### 1 ES6 对迭代器的实现

JS 原生的集合类型数据结构，只有`Array`（数组）和`Object`（对象）；而`ES6`中，又新增了`Map`和`Set`。四种数据结构各自有着自己特别的内部实现，但我们仍期待以同样的一套规则去遍历它们，所以`ES6`在推出新数据结构的同时也推出了一套**统一的接口机制**——迭代器（`Iterator`）。

`ES6`约定，任何数据结构只要具备`Symbol.iterator`属性（这个属性就是`Iterator`的具体实现，它本质上是当前数据结构默认的迭代器生成函数），就可以被遍历——准确地说，是被`for...of...`循环和迭代器的 next 方法遍历。 事实上，`for...of...`的背后正是对`next`方法的反复调用。

在 ES6 中，针对`Array`、`Map`、`Set`、`String`、`TypedArray`、函数的 `arguments` 对象、`NodeList` 对象这些原生的数据结构都可以通过`for...of...`进行遍历。原理都是一样的，此处我们拿最简单的数组进行举例，当我们用`for...of...`遍历数组时：

之所以能够按顺序一次一次地拿到数组里的每一个成员，是因为我们借助数组的`Symbol.iterator`生成了它对应的迭代器对象，通过反复调用迭代器对象的`next`方法访问了数组成员，像这样：

丢进控制台，我们可以看到`next`每次会按顺序帮我们访问一个集合成员：

![](<./hand-write.assets/1695616415762.png>)

而`for...of...`做的事情，基本等价于下面这通操作：

可以看出，`for...of...`其实就是`iterator`循环调用换了种写法。在 ES6 中我们之所以能够开心地用`for...of...`遍历各种各种的集合，全靠迭代器模式在背后给力。

ps：此处推荐阅读[迭代协议 (opens new window)](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols)，相信大家读过后会对迭代器在 ES6 中的实现有更深的理解。

### 2 实现迭代器生成函数

我们说**迭代器对象**全凭**迭代器生成函数**帮我们生成。在`ES6`中，实现一个迭代器生成函数并不是什么难事儿，因为 ES6 早帮我们考虑好了全套的解决方案，内置了贴心的**生成器**（`Generator`）供我们使用：

丢进控制台，不负众望：

![](<./hand-write.assets/1695616416818.png>)

写一个生成器函数并没有什么难度，但在面试的过程中，面试官往往对生成器这种语法糖背后的实现逻辑更感兴趣。下面我们要做的，不仅仅是写一个迭代器对象，而是用`ES5`去写一个能够生成迭代器对象的迭代器生成函数（解析在注释里）：

此处为了记录每次遍历的位置，我们实现了一个闭包，借助自由变量来做我们的迭代过程中的 “游标”。

运行一下我们自定义的迭代器，结果符合预期：

![](<./hand-write.assets/1695616421698.png>)

## 20 实现 ES6 的 extends

## 21 实现 Object.create

`Object.create()`方法创建一个新对象，使用现有的对象来提供新创建的对象的 `__proto__`

## 22 实现 Object.freeze

`Object.freeze`冻结一个对象，让其不能再添加 / 删除属性，也不能修改该对象已有属性的可枚举性、可配置可写性，也不能修改已有属性的值和它的原型属性，最后返回一个和传入参数相同的对象

## 23 实现 Object.is

`Object.is`不会转换被比较的两个值的类型，这点和`===`更为相似，他们之间也存在一些区别

*   `NaN`在`===`中是不相等的，而在`Object.is`中是相等的
*   `+0`和`-`0 在`===`中是相等的，而在`Object.is`中是不相等的

## 24 实现一个 compose 函数

组合多个函数，从右到左，比如：`compose(f, g, h)` 最终得到这个结果 `(...args) => f(g(h(...args))).`

题目描述: 实现一个 `compose` 函数

**实现代码如下**

`compose`创建了一个从右向左执行的数据流。如果要实现从左到右的数据流，可以直接更改`compose`的部分代码即可实现

*   更换`Api`接口：把`reduce`改为`reduceRight`
*   交互包裹位置：把`a(b(...args))`改为`b(a(...args))`

## 25 setTimeout 与 setInterval 实现

### 1 setTimeout 模拟实现 setInterval

题目描述: `setInterval` 用来实现循环定时调用 可能会存在一定的问题 能用 `setTimeout` 解决吗

实现代码如下:

为什么要用 `setTimeout` 模拟实现 `setInterval`？`setInterval` 的缺陷是什么？

上面这句代码的意思其实是`fn()`将会在 `N` 秒之后被推入任务队列。在 `setInterval` 被推入任务队列时，如果在它前面有很多任务或者某个任务等待时间较长比如网络请求等，那么这个定时器的执行时间和我们预定它执行的时间可能并不一致

**再次强调**，定时器指定的时间间隔，表示的是何时将定时器的代码添加到消息队列，而不是何时执行代码。所以真正何时执行代码的时间是不能保证的，取决于何时被主线程的事件循环取到，并执行。

![](<./hand-write.assets/1695616423203.png>)

上图可见，`setInterval` 每隔 `100ms` 往队列中添加一个事件；`100ms` 后，添加 `T1` 定时器代码至队列中，主线程中还有任务在执行，所以等待，`some event` 执行结束后执行 `T1`定时器代码；又过了 `100ms`，`T2` 定时器被添加到队列中，主线程还在执行 `T1` 代码，所以等待；又过了 `100ms`，理论上又要往队列里推一个定时器代码，但由于此时 `T2` 还在队列中，所以 `T3` 不会被添加（`T3` 被跳过），结果就是此时被跳过；这里我们可以看到，`T1` 定时器执行结束后马上执行了 T2 代码，所以并没有达到定时器的效果

**setInterval 有两个缺点**

*   使用`setInterval`时，某些间隔会被跳过
*   可能多个定时器会连续执行

**可以这么理解**：每个`setTimeout`产生的任务会直接`push`到任务队列中；而`setInterval`在每次把任务`push`到任务队列前，都要进行一下判断 (看上次的任务是否仍在队列中)。因而我们一般用`setTimeout`模拟`setInterval`，来规避掉上面的缺点

### 2 setInterval 模拟实现 setTimeout

## 26 实现 Node 的 require 方法

**require 基本原理**

![](<./hand-write.assets/1695616432101.png>)

**require 查找路径**

![](<./hand-write.assets/1695616434333.png>)

`require` 和 `module.exports` 干的事情并不复杂，我们先假设有一个全局对象`{}`，初始情况下是空的，当你 `require` 某个文件时，就将这个文件拿出来执行，如果这个文件里面存在`module.exports`，当运行到这行代码时将 `module.exports` 的值加入这个对象，键为对应的文件名，最终这个对象就长这样：

当你再次 `require` 某个文件时，如果这个对象里面有对应的值，就直接返回给你，如果没有就重复前面的步骤，执行目标文件，然后将它的 `module.exports` 加入这个全局对象，并返回给调用者。这个全局对象其实就是我们经常听说的缓存。所以 `require` 和 `module.exports` 并没有什么黑魔法，就只是运行并获取目标文件的值，然后加入缓存，用的时候拿出来用就行

**手写实现一个 require**

## 27 实现 LRU 淘汰算法

`LRU` 缓存算法是一个非常经典的算法，在很多面试中经常问道，不仅仅包括前端面试

`LRU` 英文全称是 `Least Recently Used`，英译过来就是” **最近最少使用** “的意思。`LRU` 是一种常用的页面置换算法，选择最近最久未使用的页面予以淘汰。该算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 `t`，当须淘汰一个页面时，选择现有页面中其 `t` 值最大的，即最近最少使用的页面予以淘汰

通俗的解释：

假如我们有一块内存，专门用来缓存我们最近发访问的网页，访问一个新网页，我们就会往内存中添加一个网页地址，随着网页的不断增加，内存存满了，这个时候我们就需要考虑删除一些网页了。这个时候我们找到内存中最早访问的那个网页地址，然后把它删掉。这一整个过程就可以称之为 `LRU` 算法

![](<./hand-write.assets/1695616435957.png>)

上图就很好的解释了 `LRU` 算法在干嘛了，其实非常简单，无非就是我们往内存里面添加或者删除元素的时候，遵循**最近最少使用原则**

**使用场景**

`LRU` 算法使用的场景非常多，这里简单举几个例子即可：

*   我们操作系统底层的内存管理，其中就包括有 `LRU` 算法
*   我们常见的缓存服务，比如 `redis` 等等
*   比如浏览器的最近浏览记录存储
*   `vue`中的`keep-alive`组件使用了`LRU`算法

**梳理实现 LRU 思路**

*   特点分析：
    *   我们需要一块有限的存储空间，因为无限的化就没必要使用`LRU`算发删除数据了。
    *   我们这块存储空间里面存储的数据需要是有序的，因为我们必须要顺序来删除数据，所以可以考虑使用 `Array`、`Map` 数据结构来存储，不能使用 `Object`，因为它是无序的。
    *   我们能够删除或者添加以及获取到这块存储空间中的指定数据。
    *   存储空间存满之后，在添加数据时，会自动删除时间最久远的那条数据。
*   实现需求：
    *   实现一个 `LRUCache` 类型，用来充当存储空间
    *   采用 `Map` 数据结构存储数据，因为它的存取时间复杂度为 `O(1)`，数组为 `O(n)`
    *   实现 `get` 和 `set` 方法，用来获取和添加数据
    *   我们的存储空间有长度限制，所以无需提供删除方法，存储满之后，自动删除最久远的那条数据
    *   当使用 `get` 获取数据后，该条数据需要更新到最前面

**具体实现**

*   `set 方法`：往 `map` 里面添加新数据，如果添加的数据存在了，则先删除该条数据，然后再添加。如果添加数据后超长了，则需要删除最久远的一条数据。`data.keys().next().value` 便是获取最后一条数据的意思。
*   `get 方法`：首先从 `map` 对象中拿出该条数据，然后删除该条数据，最后再重新插入该条数据，确保将该条数据移动到最前面

![](<./hand-write.assets/1695616437191.png>)

继续插入数据，此时会超长，代码如下：

![](<./hand-write.assets/1695616439921.png>)

此时我们发现存储时间最久的 name 已经被移除了，新插入的数据变为了最前面的一个。

我们使用 `get` 获取数据，代码如下：

![](<./hand-write.assets/1695616440718.png>)

我们发现此时 `sex` 字段已经跑到最前面去了

**总结**

`LRU` 算法其实逻辑非常的简单，明白了原理之后实现起来非常的简单。最主要的是我们需要使用什么数据结构来存储数据，因为 `map` 的存取非常快，所以我们采用了它，当然数组其实也可以实现的。还有一些小伙伴使用链表来实现 `LRU`，这当然也是可以的。

## 28 框架相关

### 1 将虚拟 Dom 转化为真实 Dom

实现

### 2 实现事件总线结合 Vue 应用

`Event Bus`（Vue、Flutter 等前端框架中有出镜）和 `Event Emitter`（Node 中有出镜）出场的 “剧组” 不同，但是它们都对应一个共同的角色——**全局事件总线**。

全局事件总线，严格来说不能说是观察者模式，而是发布 - 订阅模式。它在我们日常的业务开发中应用非常广。

如果只能选一道题，那这道题一定是 `Event Bus/Event Emitter` 的代码实现——我都说这么清楚了，这个知识点到底要不要掌握、需要掌握到什么程度，就看各位自己的了。

**在 Vue 中使用 Event Bus 来实现组件间的通讯**

`Event Bus/Event Emitter` 作为全局事件总线，它起到的是一个**沟通桥梁**的作用。我们可以把它理解为一个事件中心，我们所有事件的订阅 / 发布都不能由订阅方和发布方 “私下沟通”，必须要委托这个事件中心帮我们实现。

在 Vue 中，有时候 A 组件和 B 组件中间隔了很远，看似没什么关系，但我们希望它们之间能够通信。这种情况下除了求助于 `Vuex` 之外，我们还可以通过 `Event Bus` 来实现我们的需求。

创建一个 `Event Bus`（本质上也是 Vue 实例）并导出：

在主文件里引入`EventBus`，并挂载到全局：

订阅事件：

发布（触发）事件：

大家会发现，整个调用过程中，没有出现具体的发布者和订阅者（比如上面的`PrdPublisher`和`DeveloperObserver`），全程只有`bus`这个东西一个人在疯狂刷存在感。这就是全局事件总线的特点——所有事件的发布 / 订阅操作，必须经由事件中心，禁止一切 “私下交易”！

**实现方式 1**

**实现方式 2**

*   **分析**
    *   `on`和`once`注册函数，存储起来
    *   `emit`时找到对应的函数，执行
    *   `off`找到对应函数，从存储中删除
*   **注意**
    *   `on`绑定的事件可以连续执行，除非`off`
    *   `once`绑定的函数`emit`一次即删除，也可以未执行而被`off`

**实现方式 3：拆分保存 on 和 once 事件**

在日常的开发中，大家用到`EventBus/EventEmitter`往往提供比这五个方法多的多的多的方法。但在面试过程中，如果大家能够完整地实现出这五个方法，已经非常可以说明问题了，因此这个`EventBus`希望大家可以熟练掌握。学有余力的同学，推荐阅读 [FaceBook 推出的通用 EventEmiiter 库的源码 (opens new window)](https://github.com/facebook/emitter)，相信你会有更多收获。

### 3 实现一个双向绑定

**defineProperty 版本**

**proxy 版本**

### 4 实现一个简易的 MVVM

实现一个简易的`MVVM`我会分为这么几步来：

1.  首先我会定义一个类`Vue`，这个类接收的是一个`options`，那么其中可能有需要挂载的根元素的`id`，也就是`el`属性；然后应该还有一个`data`属性，表示需要双向绑定的数据
2.  其次我会定义一个`Dep`类，这个类产生的实例对象中会定义一个`subs`数组用来存放所依赖这个属性的依赖，已经添加依赖的方法`addSub`，删除方法`removeSub`，还有一个`notify`方法用来遍历更新它`subs`中的所有依赖，同时 Dep 类有一个静态属性`target`它用来表示当前的观察者，当后续进行依赖收集的时候可以将它添加到`dep.subs`中。
3.  然后设计一个`observe`方法，这个方法接收的是传进来的`data`，也就是`options.data`，里面会遍历`data`中的每一个属性，并使用`Object.defineProperty()`来重写它的`get`和`set`，那么这里面呢可以使用`new Dep()`实例化一个`dep`对象，在`get`的时候调用其`addSub`方法添加当前的观察者`Dep.target`完成依赖收集，并且在`set`的时候调用`dep.notify`方法来通知每一个依赖它的观察者进行更新
4.  完成这些之后，我们还需要一个`compile`方法来将 HTML 模版和数据结合起来。在这个方法中首先传入的是一个`node`节点，然后遍历它的所有子级，判断是否有`firstElmentChild`，有的话则进行递归调用 compile 方法，没有`firstElementChild`的话且该`child.innderHTML`用正则匹配满足有`/\{\{(.*)\}\}/`项的话则表示有需要双向绑定的数据，那么就将用正则`new Reg('\\{\\{\\s*' + key + '\\s*\\}\\}', 'gm')`替换掉是其为`msg`变量。
5.  完成变量替换的同时，还需要将`Dep.target`指向当前的这个`child`，且调用一下`this.opt.data[key]`，也就是为了触发这个数据的`get`来对当前的`child`进行依赖收集，这样下次数据变化的时候就能通知`child`进行视图更新了，不过在最后要记得将`Dep.target`指为`null`哦 (其实在`Vue`中是有一个`targetStack`栈用来存放`target`的指向的)
6.  那么最后我们只需要监听`document`的`DOMContentLoaded`然后在回调函数中实例化这个`Vue`对象就可以了

**coding**:

需要注意的点：

*   `childNodes`会获取到所有的子节点以及文本节点 (包括元素标签中的空白节点)
*   `firstElementChild`表示获取元素的第一个字元素节点，以此来区分是不是元素节点，如果是的话则调用`compile`进行递归调用，否则用正则匹配
*   这里面的正则真的不难，大家可以看一下

完整代码如下：

**简化版 2**

### 5 实现一个迷你版的 vue

**入口**

**实现 Dep**

**实现 watcher**

**实现 compiler**

**实现 Observer**

**使用**

### 6 实现 Vue reactive 响应式

### 7 实现模板字符串解析功能

### 8 实现一下 hash 路由

基础的`html`代码：

简单实现：

封装成一个 class:

### 9 实现 redux 中间件

**简单实现**

**2. 迷你版**

### 10 实现 redux-thunk

`redux-thunk` 可以利用 `redux` 中间件让 `redux` 支持异步的 `action`

## 29 数组相关

### 1 实现 forEach 方法

### 2 实现 filter 方法

### 3 实现 find 方法

*   `find` 接收一个方法作为参数，方法内部返回一个条件
*   `find` 会遍历所有的元素，执行你给定的带有条件返回值的函数
*   符合该条件的元素会作为 `find` 方法的返回值
*   如果遍历结束还没有符合该条件的元素，则返回 `undefined`

### 4 实现 findIndex 方法

### 5 实现 map 方法

*   回调函数的参数有哪些，返回值如何处理
*   不修改原来的数组

### 6 实现 reduce 方法

*   初始值不传怎么处理
*   回调函数的参数有哪些，返回值如何处理。

### 7 实现 every 方法

### 8 实现 some 方法

### 9 实现数组扁平化 flat 方法

题目描述: 实现一个方法使多维数组变成一维数组

**第 0 种处理: 直接的调用**

**第一种处理**

**第二种处理**

**第三种处理：递归处理**

**第四种处理：用 reduce 实现数组的 flat 方法**

**第五种处理：能用迭代的思路去实现**

**第六种处理：扩展运算符**

### 10 实现 Array.isArray 方法

### 11 实现 Array.of 方法

`Array.of()`方法用于将一组值，转换为数组

*   这个方法的主要目的，是弥补数组构造函数`Array()`的不足。因为参数个数的不同，会导致`Array()`的行为有差异。
*   `Array.of()`基本上可以用来替代`Array()`或`new Array()`，并且不存在由于参数不同而导致的重载。它的行为非常统一

**实现**

### 12 数组去重方法汇总

首先: 我知道多少种去重方式

**1. 双层 for 循环**

思想: 双重 `for` 循环是比较笨拙的方法，它实现的原理很简单：先定义一个包含原始数组第一个元素的数组，然后遍历原始数组，将原始数组中的每个元素与新数组中的每个元素进行比对，如果不重复则添加到新数组中，最后返回新数组；因为它的时间复杂度是`O(n^2)`，如果数组长度很大，效率会很低

**2. Array.filter() 加 indexOf/includes**

思想: 利用`indexOf`检测元素在数组中第一次出现的位置是否和元素现在的位置相等，如果不等则说明该元素是重复元素

**3. ES6 中的 Set 去重**

思想: ES6 提供了新的数据结构 Set，Set 结构的一个特性就是成员值都是唯一的，没有重复的值。

**4. reduce 实现对象数组去重复**

这种方法是利用高阶函数 `reduce` 进行去重， 这里只需要注意`initialValue`得放一个空数组 []，不然没法`push`

### 13 对象数组如何去重

根据每个对象的某一个具体属性来进行去重

### 14 数组中的数据根据 key 去重

给定一个任意数组，实现一个通用函数，让数组中的数据根据 key 排重：

**实现**

**使用**

### 15 类数组转化为数组的方法

### 16 reduce 用法汇总

**语法**

`reduceRight()` 该方法用法与`reduce()`其实是相同的，只是遍历的顺序相反，它是从数组的最后一项开始，向前遍历到第一项

**1. 数组求和**

**2. 数组最大值**

**3. 数组转对象**

**4. 扁平一个二维数组**

**5. 数组去重**

**6. 对象数组去重**

**7. 求字符串中字母出现的次数**

**8. compose 函数**

`redux compose` 源码实现

## 30 正则相关

### 1 实现千位分隔符

### 2 判断是否是电话号码

### 3 验证是否是邮箱

### 4 验证是否是身份证

### 5 用正则写一个根据 name 获取 cookie 中的值的方法

1.  获取页面上的`cookie`可以使用 `document.cookie`

这里获取到的是类似于这样的字符串：

**可以看到这么几个信息：**

*   每一个 cookie 都是由 `name=value` 这样的形式存储的
*   每一项的开头可能是一个空串`''`(比如`username`的开头其实就是), 也可能是一个空字符串`' '`（比如`user-id`的开头就是）
*   每一项用`";"`来区分
*   如果某项中有多个值的时候，是用`","`来连接的 (比如`user-roles`的值)
*   每一项的结尾可能是有`";"`的 (比如`username`的结尾)，也可能是没有的 (比如`user-roles`的结尾)

2.  所以我们将这里的正则拆分一下：

*   `'(^| )'`表示的就是获取每一项的开头，因为我们知道如果`^`不是放在`[]`里的话就是表示开头匹配。所以这里`(^| )`的意思其实就被拆分为`(^)`表示的匹配`username`这种情况，它前面什么都没有是一个空串 (你可以把`(^)`理解为`^`它后面还有一个隐藏的`''`)；而`|`表示的就是或者是一个`" "`(为了匹配`user-id`开头的这种情况)
*   `+name+`这没什么好说的
*   `=([^;]*)`这里匹配的就是`=`后面的值了，比如`poetry`；刚刚说了`^`要是放在`[]`里的话就表示`"除了^后面的内容都能匹配"`，也就是非的意思。所以这里`([^;]*)`表示的是除了`";"`这个字符串别的都匹配 (`*`应该都知道什么意思吧，匹配 0 次或多次)
*   有的大佬等号后面是这样写的`'=([^;]*)(;|$)'`，而最后为什么可以把`'(;|$)'`给省略呢？因为其实最后一个`cookie`项是没有`';'`的，所以它可以合并到`=([^;]*)`这一步。

3.  最后获取到的`match`其实是一个长度为 4 的数组。比如：

*   第 0 项：全量
*   第 1 项：开头
*   第 2 项：中间的值
*   第 3 项：结尾

所以我们是要拿第 2 项`match[2]`的值。

4.  为了防止获取到的值是`%xxx`这样的字符序列，需要用`unescape()`方法解码。

## 31 函数柯里化相关

### 1 实现一个 JS 函数柯里化

**预先处理的思想，利用闭包的机制**

*   柯里化的定义：接收一部分参数，返回一个函数接收剩余参数，接收足够参数后，执行原函数
*   函数柯里化的主要作用和特点就是`参数复用`、`提前返回`和`延迟执行`

*   柯里化把多次传入的参数合并，柯里化是一个高阶函数
*   每次都返回一个新函数
*   每次入参都是一个

当柯里化函数接收到足够参数后，就会执行原函数，如何去确定何时达到足够的参数呢？

**有两种思路：**

*   通过函数的 `length` 属性，获取函数的形参个数，形参的个数就是所需的参数个数
*   在调用柯里化工具函数时，手动指定所需的参数个数

将这两点结合一下，实现一个简单 `curry` 函数

**通用版**

**ES6 写法**

### 2 请实现一个 add 函数，满足以下功能

考点：

*   使用闭包， 同时要对 JavaScript 的作用域链（原型链）有深入的理解
*   重写函数的 `toSting()`方法

### 3 实现 (5).add(3).minus(2) 功能

例： 5 + 3 - 2，结果为 6

**实现 add(1)(2) =3**

无限链式调用实现的关键在于 **对象的 toString 方法**: 每个对象都有一个 `toString()` 方法，当该对象被表示为一个文本值时，或者一个对象以预期的字符串方式引用时自动调用。

也就是我在调用很多次后，他们的结果会存在`add`函数中的`sum`变量上，当我`alert`的时候 `add`会自动调用 `toString`方法 打印出 `sum,` 也就是最终的结果

## 32 字符串相关

### 1 查找字符串中出现最多的字符和个数

例: abbcccddddd -> 字符最多的是 d，出现了 5 次

### 2 字符串查找

请使用最基本的遍历来实现判断字符串 a 是否被包含在字符串 b 中，并返回第一次出现的位置（找不到返回 -1）。

### 3 字符串最长的不重复子串

题目描述

答案

## 33 实现工具函数

### 1 对象扁平化

### 2 实现一个管理本地缓存过期的函数

封装一个可以设置过期时间的`localStorage`存储函数

**用法**

下面我把值取出来

设置 5 秒过期

### 3 实现 lodash 的 chunk 方法 -- 数组按指定长度拆分

**题目**

**实现**

### 4 手写深度比较 isEqual

思路：深度比较两个对象，就是要深度比较对象的每一个元素。=> 递归

*   递归退出条件：
    *   被比较的是两个值类型变量，直接用 “===” 判断
    *   被比较的两个变量之一为`null`，直接判断另一个元素是否也为`null`
*   提前结束递推：
    *   两个变量`keys`数量不同
    *   传入的两个参数是同一个变量
*   递推工作：深度比较每一个`key`

### 5 实现一个 JSON.stringify

*   `Boolean | Number| String`类型会自动转换成对应的原始值。
*   `undefined`、任意函数以及`symbol`，会被忽略（出现在非数组对象的属性值中时），或者被转换成 `null`（出现在数组中时）。
*   不可枚举的属性会被忽略如果一个对象的属性值通过某种间接的方式指回该对象本身，即循环引用，属性也会被忽略
*   如果一个对象的属性值通过某种间接的方式指回该对象本身，即循环引用，属性也会被忽略

### 6 实现一个 JSON.parse

用来解析 JSON 字符串，构造由字符串描述的 JavaScript 值或对象。提供可选的 reviver 函数用以在返回之前对所得到的对象执行变换 (操作)

**第一种：直接调用 eval**

避免在不必要的情况下使用 `eval`，`eval()` 是一个危险的函数，他执行的代码拥有着执行者的权利。如果你用`eval()`运行的字符串代码被恶意方（不怀好意的人）操控修改，您最终可能会在您的网页 / 扩展程序的权限下，在用户计算机上运行恶意代码。它会执行 JS 代码，有 XSS 漏洞。

如果你只想记这个方法，就得对参数 json 做校验。

**第二种：Function**

核心：Function 与 eval 有相同的字符串参数特性

在转换 JSON 的实际应用中，只需要这么做

`eval` 与 `Function`都有着动态编译 js 代码的作用，但是在实际的编程中并不推荐使用

### 7 解析 URL Params 为对象

### 8 转化为驼峰命名

### 9 实现一个函数判断数据类型

### 10 对象数组列表转成树形结构（处理菜单）

实现代码如下:

### 11 树形结构转成列表（处理菜单）

实现代码如下:

## 34 手写常见排序

![](<./hand-write.assets/1695616443061.png>)

### 1 冒泡排序

冒泡排序的原理如下，从第一个元素开始，把当前元素和下一个索引元素进行比较。如果当前元素大，那么就交换位置，重复操作直到比较到最后一个元素，那么此时最后一个元素就是该数组中最大的数。下一轮重复以上操作，但是此时最后一个元素已经是最大数了，所以不需要再比较最后一个元素，只需要比较到 `length - 1` 的位置。

### 2 快速排序

**思路分析**

*   找到中间位置`midValue`
*   遍历数组，小于`midValue`放在`left`，否则放在`right`
*   继续递归，最后`concat`拼接返回
*   使用`splice`会修改原数组，使用`slice`不会修改原数组（推荐）
*   一层遍历 + 二分的时间复杂度是`O(nlogn)`

![](<./hand-write.assets/1695616443106.png>)

**快速排序（使用 splice）**

**快速排序（使用 slice）**

### 3 选择排序

### 4 插入排序

### 5 二分查找

## 35 算法数据结构

### 1 实现一个链表结构

链表结构

![](<./hand-write.assets/1695616443709.png>)

看图理解 next 层级

![](<./hand-write.assets/1695616444708.png>)

### 2 实现一个队列

基于链表结构实现队列

### 3 递归反转链表

### 4 二叉树搜索

![](<./hand-write.assets/1695616446386.png>)

![](<./hand-write.assets/1695616447544.png>)

### 5 二叉树层次遍历

### 6 二叉树深度遍历

先序遍历

![](<./hand-write.assets/1695616447893.png>)

二叉树的遍历方式

![](<./hand-write.assets/1695616447990.png>)

## 36 综合

### 1 实现一个 sleep 函数，比如 sleep(1000) 意味着等待 1000 毫秒

### 2 给定两个数组，写一个方法来计算它们的交集

例如：给定 nums1 = [1, 2, 2, 1]，nums2 = [2, 2]，返回 [2, 2]。

### 3 异步并发数限制

### 4 异步串行 | 异步并行

### 5 实现有并行限制的 Promise 调度器

题目描述: JS 实现一个带并发限制的异步调度器 `Scheduler`，保证同时运行的任务最多有两个

实现代码如下:

### 6 图片懒加载

### 7 实现 getValue/setValue 函数来获取 path 对应的值

**实现**

**使用 promise 来实现**

创建 `enhancedObject` 函数

使用 `enhancedObject` 函数

以上代码运行后，控制台会输出以下代码：

通过观察以上的输出结果可知，使用 `enhancedObject` 函数处理过的对象，我们就可以方便地访问普通对象内部的深层属性。

### 8 创建 10 个标签，点击的时候弹出来对应的序号

### 9 版本号排序的方法

题目描述: 有一组版本号如下 `['0.1.1', '2.3.3', '0.302.1', '4.2', '4.3.5', '4.3.4.5']`。现在需要对其进行排序，排序的结果为 `['4.3.5','4.3.4.5','2.3.3','0.302.1','0.1.1']`

### 10 请实现 DOM2JSON 一个函数，可以把一个 DOM 节点输出 JSON 的格式

实现代码如下:

### 11 分片思想解决大数据量渲染问题

题目描述: 渲染百万条结构简单的大数据时 怎么使用分片思想优化渲染

**扩展思考**：对于大数据量的简单 `dom` 结构渲染可以用分片思想解决 如果是复杂的 `dom` 结构渲染如何处理？

这时候就需要使用**虚拟列表**了，虚拟列表和虚拟表格在日常项目使用还是很多的

### 12 实现一个 add 方法完成两个大数相加

实现代码如下:

### 13 怎么在制定数据源里面生成一个长度为 n 的不重复随机数组 能有几种方法 时间复杂度多少（字节）

**第一版 时间复杂度为 O(n^2)**

**第二版 标记法 / 自定义属性法 时间复杂度为 O(n)**

**第三版 交换法 时间复杂度为 O(n)**

值得一提的是操作数组的时候使用交换法 这种思路在算法里面很常见

**最终版 边遍历边删除 时间复杂度为 O(n)**

### 14 查找数组公共前缀（美团）

题目描述

答案

### 15 判断括号字符串是否有效（小米）

题目描述

答案

### 16 实现一个 padStart() 或 padEnd() 的 polyfil

`String.prototype.padStart` 和 `String.prototype.padEnd`是`ES8`中新增的方法，允许将空字符串或其他字符串添加到原始字符串的开头或结尾。我们先看下使用语法：

用法：

polyfill 实现：

还是比较简单的，而`padEnd`的实现和它一样，只需要把第二层`for`循环里的`${padString[j]}${orignStr}`换下位置就可以了。

### 17 设计一个方法提取对象中所有 value 大于 2 的键值对并返回最新的对象

实现：

方法有很多种，这里提供一种比较简洁的写法，用到了`ES10`的`Object.fromEntries()`：

### 18 实现一个拖拽

### 19 基于 Promise.all 实现 Ajax 的串行和并行

基于 Promise.all 实现 Ajax 的串行和并行

*   串行：请求是异步的，需要等待上一个请求成功，才能执行下一个请求
*   并行：同时发送多个请求「`HTTP`请求可以同时进行，但是 JS 的操作都是一步步的来的，因为 JS 是单线程」, 等待所有请求都成功，我们再去做什么事情?

**Promise.all 并发限制及 async-pool 的应用**

并发限制指的是，每个时刻并发执行的 promise 数量是固定的，最终的执行结果还是保持与原来的

**JS 实现 Ajax 并发请求控制的两大解决方案**

`tasks`：数组，数组包含很多方法，每一个方法执行就是发送一个请求「基于`Promise`管理」

### 20 修改嵌套层级很深对象的 key

**方法 1：序列化 JSON.stringify + 正则匹配**

**方法 2：递归**